<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OBJ Test</title>
</head>
<body>
<canvas id="glcanvas" width="640" height="480"></canvas>
<div>
    <input type="file" id="files"/>
    <input type="button" id="import" value="导入" onclick="objReader();"/>
    <input type="button" id="deleteOBJ" value="delete" onclick="deleteObjFromHtml('a_obj');">
    <input type="button" id="display" value="display" onclick="main();">
</div>
<div id="obj-info" hidden="hidden"></div>
</body>
<script src="../src/dist/js/jquery.min.js"></script>
<script src="../src/js/gl-matrix.js"></script>
<script src="../src/js/draw_basic_object.js"></script>
<!--<script src="../src/js/basic_object_with_texture.js"></script>-->
<script src="../src/js/objreader.js"></script>
<script>
    function main() {
        const canvas = document.querySelector('#glcanvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) {
            alert('Unable to initialize WebGL. Your browser or machine may not support it.');
            return;
        }
        //console.log("Running");
        // Vertex shader program

        const vsSource = `
        precision lowp float;
        attribute vec4 aVertexPosition;
        attribute vec4 aVertexAmbientColor;
        attribute vec4 aVertexDiffuseColor;
        attribute vec4 aVertexSpecularColor;
        // attribute vec4 aVertexColor;
        attribute vec3 aVertexNormal;
        attribute vec2 aTextureCoord;

        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;
        uniform mat4 uNormalMatrix;

        varying vec4 vPosition;
        varying vec4 vAmbientColor;
        varying vec4 vDiffuseColor;
        varying vec4 vSpecularColor;
        // varying vec4 vColor;
        varying vec2 vTextureCoord;
        varying vec4 vTransformedNormal;

        void main(void) {
            vPosition = uModelViewMatrix * aVertexPosition;
            vAmbientColor = aVertexAmbientColor;
            vDiffuseColor = aVertexDiffuseColor;
            vSpecularColor = aVertexSpecularColor;
            gl_Position = uProjectionMatrix * vPosition;
            vTextureCoord = aTextureCoord;
            vTransformedNormal = uNormalMatrix*vec4(aVertexNormal,1.0);
        }
        `;

        // Fragment shader program

        const fsSource = `
        #define MAX_LIGHT_NUM 5
        precision lowp float;
        uniform bool uUseTexture;

        uniform float uMaterialShiness;
        uniform vec3 uEyePosition;
        uniform int uLightNum;
        uniform vec3 uPointLightingLocation[MAX_LIGHT_NUM];
        uniform vec3 uPointLightingSpecularColor[MAX_LIGHT_NUM];
        uniform vec3 uPointLightingDiffuseColor[MAX_LIGHT_NUM];
        uniform vec3 uAmbientLight;

        // the variable share with vsSource
        varying vec4 vPosition;
        varying vec4 vAmbientColor;
        varying vec4 vDiffuseColor;
        varying vec4 vSpecularColor;
        // varying vec4 vColor;
        varying vec2 vTextureCoord;
        varying vec4 vTransformedNormal;

        uniform sampler2D uSampler;

        void main(void) {
            vec3 lighting = uAmbientLight;
            vec3 normal = normalize(vTransformedNormal.xyz);
            vec3 eyeDirection = normalize(uEyePosition - vec3(vPosition));
            vec3 origColor = uAmbientLight*vAmbientColor.rgb;

            for (int i = 0;i < MAX_LIGHT_NUM;i++) {
                if (i < uLightNum) {
                    // the direction for point light
                    vec3 directionalVector = normalize(uPointLightingLocation[i] - vec3(vPosition));
                    vec3 reflectionDirection = reflect(-directionalVector, normal);

                    float specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShiness);
                    float diffuseLightWeighting = max(dot(normal, directionalVector), 0.0);

                    // lighting = uAmbientLight+ uPointLightingDiffuseColor * diffuseLightWeighting;
                    lighting += uPointLightingSpecularColor[i] * specularLightWeighting
                        + uPointLightingDiffuseColor[i] * diffuseLightWeighting;

                    origColor +=  uPointLightingSpecularColor[i]*specularLightWeighting*vSpecularColor.rgb + uPointLightingDiffuseColor[i]*diffuseLightWeighting*vDiffuseColor.rgb;
                }
            }

            if (uUseTexture) {
                vec4 texColor = texture2D(uSampler,vTextureCoord);
                gl_FragColor = vec4(texColor.rgb*lighting,  texColor.a);
            } else {
                gl_FragColor = vec4(origColor,vAmbientColor.a);
                // gl_FragColor = vec4(vAmbientColor.rgb*lighting,1.0);
            }
        }
        `;

        // Initialize a shader program; this is where all the lighting
        // for the vertices and so forth is established.
        const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

        // Collect all the info needed to use the shader program.
        // Look up which attributes our shader program is using
        // for aVertexPosition, aVevrtexColor and also
        // look up uniform locations.
        const programInfo = {
            program: shaderProgram,
            attribLocations: {
                vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                vertexAmbientColor: gl.getAttribLocation(shaderProgram, 'aVertexAmbientColor'),
                vertexDiffuseColor: gl.getAttribLocation(shaderProgram, 'aVertexDiffuseColor'),
                vertexSpecularColor: gl.getAttribLocation(shaderProgram, 'aVertexSpecularColor'),
                vertexNormal: gl.getAttribLocation(shaderProgram, 'aVertexNormal'),
                textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord'),
            },
            uniformLocations: {
                projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'),
                usePointLighting: gl.getUniformLocation(shaderProgram, 'uUsePointLighting'),
                useTexture: gl.getUniformLocation(shaderProgram, 'uUseTexture'),
                materialShiness: gl.getUniformLocation(shaderProgram, 'uMaterialShiness'),
                eyePosition: gl.getUniformLocation(shaderProgram, 'uEyePosition'),
                lightNum: gl.getUniformLocation(shaderProgram, 'uLightNum'),
                pointLightingLocation: gl.getUniformLocation(shaderProgram, 'uPointLightingLocation'),
                pointLightingSpecularColor: gl.getUniformLocation(shaderProgram, 'uPointLightingSpecularColor'),
                pointLightingDiffuseColor: gl.getUniformLocation(shaderProgram, 'uPointLightingDiffuseColor'),
                ambientLight: gl.getUniformLocation(shaderProgram, 'uAmbientLight'),
                uSampler: gl.getUniformLocation(shaderProgram, 'uSampler'),
            },
        };

        let ObjectInfo = getObjInfo('a_obj');
        let faceColors = [1.0, 1.0, 1.0, 1.0];

        //console.log(gl);
        //console.log(objInfo);
        /*var objInfo = {
            verPosition : [
                0, 0, 0,
                1, 0, 0,
                1, 1, 0,
                0, 1, 0,],
            indicesForVer : [ 0, 1, 2, 0, 2, 3,]
        };*/
        const texture = loadTexture(gl, '../images/cubetexture.png');

        gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
        gl.clearDepth(1.0);                 // Clear everything
        gl.enable(gl.DEPTH_TEST);           // Enable depth testing
        gl.depthFunc(gl.LEQUAL);            // Near things obscure far things
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        // Create a perspective matrix, a special matrix that is
        // used to simulate the distortion of perspective in a camera.
        // Our field of view is 45 degrees, with a width/height
        // ratio that matches the display size of the canvas
        // and we only want to see objects between 0.1 units
        // and 100 units away from the camera.

        const fieldOfView = 45 * Math.PI / 180;   // in radians
        const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        const zNear = 0.1;
        const zFar = 100.0;
        const projectionMatrix = mat4.create();

        // note: glmatrix.js always has the first argument
        // as the destination to receive the result.
        mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);

        let ambientLight = [0.2, 0.2, 0.2];

        let lightSource1 = {
            usePointLighting: true,
            pointLightingLocation: [0, 10, 4],
            pointLightingSpecularColor: [0.5, 0.5, 0.5],
            pointLightingDiffuseColor: [1, 1, 1],
        };

        let lightSource2 = {
            usePointLighting: true,
            pointLightingLocation: [0, 10, -4],
            pointLightingSpecularColor: [0.5, 0.5, 0.5],
            pointLightingDiffuseColor: [0.4, 0.4, 0.4],
        };


        let lightSources = [];
        lightSources = lightSources.concat(lightSource1);
        lightSources = lightSources.concat(lightSource2);

        ObjectInfo.ambientColor = [0.1, 0.1, 0.1, 1.0];
        ObjectInfo.diffuseColor = [1.0, 1.0, 1.0, 1.0];
        ObjectInfo.specularColor = [0.3, 0.3, 0.3, 1.0];
        ObjectInfo.useTexture = true;
        ObjectInfo.texture = texture;
        ObjectInfo.shiness = 10;

        ObjectInfo.transformation = {
            translation : [0.0, 0.0, -1.0],
            scale : [4.0, 4.0, 4.0],
            rotation : {x : 0.0, y : 1.0, z : 0.0}
        };

        const eyePosition = [0, 0, 5];


        function render() {

            objDisplay(gl, programInfo, projectionMatrix, ObjectInfo, ambientLight, lightSources, eyePosition);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);

    }
</script>
</html>