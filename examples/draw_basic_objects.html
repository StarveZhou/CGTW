<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>WebGL Demo</title>
    <script src="../src/js/gl-matrix.js"></script>
    <script src="../src/js/basic_object_with_texture.js"></script>
</head>

<body>
<canvas id="glcanvas" width="640" height="480"></canvas>
</body>


<script>
    main();

    //
    // Start here
    //
    function main() {
        const canvas = document.querySelector('#glcanvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) {
            alert('Unable to initialize WebGL. Your browser or machine may not support it.');
            return;
        }

        // Vertex shader program

        const vsSource = `
        precision lowp float;
        attribute vec4 aVertexPosition;
        attribute vec3 aVertexNormal;
        attribute vec2 aTextureCoord;

        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;
        uniform mat4 uNormalMatrix;
        
        varying vec4 vPosition;  
        varying vec2 vTextureCoord;
        varying vec4 vTransformedNormal;

        void main(void) {
            vPosition = uModelViewMatrix * aVertexPosition;
            gl_Position = uProjectionMatrix * vPosition;
            vTextureCoord = aTextureCoord;
            vTransformedNormal = uNormalMatrix*vec4(aVertexNormal,1.0);
        }
        `;

        // Fragment shader program

        const fsSource = `
        precision lowp float;
        uniform float uUsePointLighting;
        uniform float uMaterialShininess;
        uniform vec3 uPointLightingLocation;
        uniform vec3 uPointLightingSpecularColor;
        uniform vec3 uPointLightingDiffuseColor;
        uniform vec3 uAmbientLight;

        // the variable share with vsSource
        varying vec4 vPosition;
        varying vec2 vTextureCoord;
        varying vec4 vTransformedNormal;

        uniform sampler2D uSampler;

        void main(void) {
            vec3 lighting;

            if (uUsePointLighting == 0.0) {
                lighting = uAmbientLight;
            } else {
                 // the direction for point light
                vec3 directionalVector = normalize(uPointLightingLocation - vec3(vPosition));
                vec3 normal = normalize(vTransformedNormal.xyz);

                vec3 eyeDirection = normalize(-vPosition.xyz);
                vec3 reflectionDirection = reflect(-directionalVector, normal);

                float specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
                float diffuseLightWeighting = max(dot(normal, directionalVector), 0.0);

                // lighting = uAmbientLight                    + uPointLightingSpecularColor * specularLightWeighting;
                lighting = uAmbientLight+uPointLightingSpecularColor * specularLightWeighting
                    + uPointLightingDiffuseColor * diffuseLightWeighting;
            }    

            vec4 texColor = texture2D(uSampler,vTextureCoord);
        	gl_FragColor = vec4(texColor.rgb*lighting,  texColor.a);
        }
        `;

        // Initialize a shader program; this is where all the lighting
        // for the vertices and so forth is established.
        const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

        // Collect all the info needed to use the shader program.
        // Look up which attributes our shader program is using
        // for aVertexPosition, aVevrtexColor and also
        // look up uniform locations.
        const programInfo = {
            program: shaderProgram,
            attribLocations: {
                vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                vertexNormal: gl.getAttribLocation(shaderProgram, 'aVertexNormal'),
                textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord'),
            },
            uniformLocations: {
                projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'),
                usePointLighting: gl.getUniformLocation(shaderProgram,'uUsePointLighting'),
                materialShininess: gl.getUniformLocation(shaderProgram,'uMaterialShininess'),
                pointLightingLocation: gl.getUniformLocation(shaderProgram,'uPointLightingLocation'),
                pointLightingSpecularColor: gl.getUniformLocation(shaderProgram,'uPointLightingSpecularColor'),
                pointLightingDiffuseColor: gl.getUniformLocation(shaderProgram,'uPointLightingDiffuseColor'),
                ambientLight: gl.getUniformLocation(shaderProgram,'uAmbientLight'),
                uSampler: gl.getUniformLocation(shaderProgram, 'uSampler'),
            },
        };


        const texture = loadTexture(gl, '../images/cubetexture.png');

        // Here's where we call the routine that builds all the
        // objects we'll be drawing.
        // drawScene(gl, programInfo);
        // 
        var then = 0;
        // Draw the scene repeatedly
        function render(now) {
          now *= 0.001;  // convert to seconds
          const deltaTime = now - then;
          then = now;

          drawScene(gl, programInfo,texture);

          requestAnimationFrame(render);
        }
        requestAnimationFrame(render);

    }


    //
    // Draw the scene.
    //
    function drawScene(gl, programInfo, texture) {
        gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
        gl.clearDepth(1.0);                 // Clear everything
        gl.enable(gl.DEPTH_TEST);           // Enable depth testing
        gl.depthFunc(gl.LEQUAL);            // Near things obscure far things
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        // Create a perspective matrix, a special matrix that is
        // used to simulate the distortion of perspective in a camera.
        // Our field of view is 45 degrees, with a width/height
        // ratio that matches the display size of the canvas
        // and we only want to see objects between 0.1 units
        // and 100 units away from the camera.

        const fieldOfView = 45 * Math.PI / 180;   // in radians
        const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        const zNear = 0.1;
        const zFar = 100.0;
        const projectionMatrix = mat4.create();

        // note: glmatrix.js always has the first argument
        // as the destination to receive the result.
        mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);


       
        let positions = [
            0, 0, 0,
            1, 0, 0,
            1, 1, 0,
            0, 1, 0,

        ];

        let faceColors = [
            [1.0, 0.0, 0.0, 1.0],
        ];

        let indices = [
            0, 1, 2, 0, 2, 3,
        ];

        let  textureCoordinates = [
	  		0, 1,
	  		0, 0,
	  		1, 0,
	  		1, 1,
	  	];

        // the vertex norm for this picture 
        let vertexNormals = [
           0.0,  1.0,  1.0,
           0.0,  0.0,  1.0,
           0.0,  0.0,  1.0,
           0.0,  0.0,  1.0,
        ];

        let pointLightingLocation = [0,1,-8];
        let pointLightingSpecularColor = [1,1,1];
        let pointLightingDiffuseColor = [1,1,1];
        let ambientLight = [0.2,0.2,0.2];

        var lightSource = {
            pointLightingLocation:pointLightingLocation,
            pointLightingSpecularColor:pointLightingSpecularColor,
            pointLightingDiffuseColor:pointLightingDiffuseColor,
            ambientLight: ambientLight,
        };

        var textureSource = {
            texture:texture,
            textureCoordinates: textureCoordinates,
        }

        drawPolygon(gl, programInfo, projectionMatrix, positions, faceColors, indices, vertexNormals, textureSource, lightSource);

        positions = [
            0, 0, 0.5,
            1, 0, 0.5,
            1, 1, 0.5,
        ];

        faceColors = [
            [1.0, 1.0, 1.0, 1.0],
        ];

        indices = [
            0, 1, 2,
        ];

       	textureCoordinates = [
	  		0, 1,
	  		0, 0,
	  		1, 0,
	  	];
        // drawPolygon(gl, programInfo, projectionMatrix, positions, faceColors, indices, texture, textureCoordinates,vertexNormals,null,null,ambientLight);

    }
</script>
</html>